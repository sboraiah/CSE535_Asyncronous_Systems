# -*- generated by 1.0.12 -*-
import da
PatternExpr_236 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_241 = da.pat.BoundPattern('_BoundPattern243_')
PatternExpr_267 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_276 = da.pat.FreePattern('p')
PatternExpr_290 = da.pat.TuplePattern([da.pat.ConstantPattern('PropsedValue'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_299 = da.pat.FreePattern('p')
PatternExpr_313 = da.pat.TuplePattern([da.pat.ConstantPattern('AcceptedValue'), da.pat.FreePattern('n'), da.pat.FreePattern('v')])
PatternExpr_322 = da.pat.FreePattern('p')
PatternExpr_244 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern250_')]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_750 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_755 = da.pat.BoundPattern('_BoundPattern756_')
PatternExpr_1149 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1154 = da.pat.BoundPattern('_BoundPattern1155_')
PatternExpr_1544 = da.pat.TuplePattern([da.pat.ConstantPattern('learned')])
PatternExpr_1549 = da.pat.BoundPattern('_BoundPattern1550_')
PatternExpr_757 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern763_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_1156 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1162_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
PatternExpr_1551 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern1557_')]), da.pat.TuplePattern([da.pat.ConstantPattern('learned')])])
_config_object = {}
import sys
import random
import time
import statistics
import matplotlib.pyplot as plt1
import matplotlib.pyplot as plt2
import numpy as np
from statistics import stdev
from subprocess import call
import gc
BasicPaxos = da.import_da('test_bpaxos')
PreemptPaxos = da.import_da('preempt_paxos')

class Monitor(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._MonitorReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_MonitorReceivedEvent_0', PatternExpr_236, sources=[PatternExpr_241], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MonitorReceivedEvent_1', PatternExpr_267, sources=[PatternExpr_276], destinations=None, timestamps=None, record_history=None, handlers=[self._Monitor_handler_266]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MonitorReceivedEvent_2', PatternExpr_290, sources=[PatternExpr_299], destinations=None, timestamps=None, record_history=None, handlers=[self._Monitor_handler_289]), da.pat.EventPattern(da.pat.ReceivedEvent, '_MonitorReceivedEvent_3', PatternExpr_313, sources=[PatternExpr_322], destinations=None, timestamps=None, record_history=None, handlers=[self._Monitor_handler_312])])

    def setup(self, learners, acceptors, proposers, **rest_1785):
        super().setup(learners=learners, acceptors=acceptors, proposers=proposers, **rest_1785)
        self._state.learners = learners
        self._state.acceptors = acceptors
        self._state.proposers = proposers
        self._state.proposerVal = set()
        self._state.acceptedVal = set()
        self._state.learnerVal = set()

    def run(self):
        super()._label('yieldpt', block=False)
        _st_label_233 = 0
        while (_st_label_233 == 0):
            _st_label_233 += 1
            if PatternExpr_244.match_iter(self._MonitorReceivedEvent_0, _BoundPattern250_=self.parent(), SELF_ID=self._id):
                _st_label_233 += 1
            else:
                super()._label('yieldpt', block=True)
                _st_label_233 -= 1
        self.checkAgreement()
        self.checkValidity()
        self.checkTermination()

    def checkAgreement(self):
        if (not (len(self._state.learnerVal) == 1)):
            self.output('AGREEMENT VIOLATED')

    def checkValidity(self):
        if (len(set(self._state.proposerVal)) < len(set(self._state.learnerVal))):
            self.output('VALIDITY VIOLATED')

    def checkTermination(self):
        if (len(self._state.learnerVal) == 0):
            self.output('TERMINATION VIOLATED')

    def _Monitor_handler_266(self, n, v, p):
        if (p in self._state.learners):
            self._state.learnerVal.add(v)
    _Monitor_handler_266._labels = None
    _Monitor_handler_266._notlabels = None

    def _Monitor_handler_289(self, n, v, p):
        if (p in self._state.proposers):
            self._state.proposerVal.add(v)
    _Monitor_handler_289._labels = None
    _Monitor_handler_289._notlabels = None

    def _Monitor_handler_312(self, n, v, p):
        if (p in self._state.acceptors):
            self._state.acceptedVal.add(v)
    _Monitor_handler_312._labels = None
    _Monitor_handler_312._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._Node_ReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_750, sources=[PatternExpr_755], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_1149, sources=[PatternExpr_1154], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_2', PatternExpr_1544, sources=[PatternExpr_1549], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        nacceptors = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nproposers = (int(sys.argv[2]) if (len(sys.argv) > 2) else 3)
        nlearners = (int(sys.argv[3]) if (len(sys.argv) > 3) else 3)
        nrun = (int(sys.argv[4]) if (len(sys.argv) > 4) else 5)
        nlossrate = (float(sys.argv[5]) if (len(sys.argv) > 5) else 0.5)
        ndelay = (int(sys.argv[6]) if (len(sys.argv) > 6) else 5)
        nwaittime = (int(sys.argv[7]) if (len(sys.argv) > 7) else 5)
        ntp = (int(sys.argv[8]) if (len(sys.argv) > 8) else 1)
        ntl = (int(sys.argv[9]) if (len(sys.argv) > 9) else 20)
        (cpuStartTime, cpuEndTime, elapsedStartTime, elapsedEndTime) = (0, 0, 0, 0)
        nLossRateList = np.linspace(0, nlossrate, 5)
        nDelayList = np.linspace(0, ndelay, 5)
        nwaitList = np.linspace(0, nwaittime, 5)
        ndelayValue = int((ndelay / 5))
        nwaitValue = int((nwaittime / 5))
        LossRateCPU = {}
        LossRateELAPSED = {}
        call(['mkdir ./loss_results'], shell=True)
        plt1.figure()
        plt2.figure()
        AlgorithmList = [BasicPaxos, PreemptPaxos]
        for algorithm in AlgorithmList:
            LossRateCPU = {}
            LossRateELAPSED = {}
            CPU_Times_sd = []
            Elapsed_Times_sd = []
            sde_time_cpu = {}
            elapsed_time_cpu = {}
            self.output('LOSSRATE VARIATION', algorithm)
            print('\n')
            for nLossValue in nLossRateList:
                (cpuTime, elapsedTime) = (0, 0)
                for nrepeat in range(nrun):
                    monitor = self.new(Monitor, num=1)
                    acceptors = self.new(algorithm.Acceptor, num=nacceptors)
                    proposers = self.new(algorithm.Proposer, (acceptors, monitor, ntp, nLossValue, ndelayValue, 0), num=nproposers)
                    learners = self.new(algorithm.Learner, num=nlearners)
                    self._setup(monitor, (learners, acceptors, proposers))
                    self._start(monitor)
                    for p in acceptors:
                        self._setup(p, (learners, monitor, ndelay))
                    for p in learners:
                        self._setup(p, (acceptors, monitor, ntl))
                    cpuStartTime = time.process_time()
                    elapsedStartTime = time.time()
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_741', block=False)
                    l = None

                    def UniversalOpExpr_742():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_757.match_iter(self._Node_ReceivedEvent_0, _BoundPattern763_=l)):
                                return False
                        return True
                    _st_label_741 = 0
                    while (_st_label_741 == 0):
                        _st_label_741 += 1
                        if UniversalOpExpr_742():
                            _st_label_741 += 1
                        else:
                            super()._label('_st_label_741', block=True)
                            _st_label_741 -= 1
                    else:
                        if (_st_label_741 != 2):
                            continue
                    if (_st_label_741 != 2):
                        break
                    self.send(('done',), to=(acceptors | proposers))
                    cpuEndTime = time.process_time()
                    elapsedEndTime = time.time()
                    cpuTime += (cpuEndTime - cpuStartTime)
                    elapsedTime += (elapsedEndTime - elapsedStartTime)
                    CPU_Times_sd.append(cpuTime)
                    Elapsed_Times_sd.append(elapsedTime)
                    self.send(('done',), to=monitor)
                    gc.collect()
                cpuTime = float((cpuTime / nrun))
                elapsedTime = float((elapsedTime / nrun))
                LossRateCPU[round(nLossValue, 2)] = round(cpuTime, 5)
                LossRateELAPSED[round(nLossValue, 2)] = round(elapsedTime, 5)
                sde_time_cpu[round(nLossValue, 2)] = round(stdev(CPU_Times_sd, xbar=0), 5)
                elapsed_time_cpu[round(nLossValue, 2)] = round(stdev(Elapsed_Times_sd, xbar=0), 5)
            print('LOSSRATE VARIATION v/s MEAN CPU TIME', LossRateCPU)
            print('LOSSRATE VARIATION v/s MEAN ELAPSED TIME', LossRateELAPSED)
            print('STANDARD DEVIATION OF CPU TIME', sde_time_cpu)
            print('STANDARD DEVIATION OF ELAPSED TIME', elapsed_time_cpu)
            print('\n')
            lists = sorted(LossRateCPU.items())
            (x, y) = zip(*lists)
            plt1.plot(x, y, label='LossRateAvgCPUTime')
            lists2 = sorted(LossRateELAPSED.items())
            (x, y) = zip(*lists2)
            plt2.plot(x, y, label='LossRateAvgELAPSEDTime')
        plt1.legend(['BasicPaxosCPUTime', 'BasicPaxosELAPSEDTime', 'PremeptionCPUTime', 'PreemptionELAPSEDTime'], loc='upper left', prop={'size': 5})
        filename = ('./loss_results/' + 'loss1.png')
        plt1.savefig(filename)
        plt2.legend(['BasicPaxosCPUTime', 'BasicPaxosELAPSEDTime', 'PremeptionCPUTime', 'PreemptionELAPSEDTime'], loc='upper left', prop={'size': 5})
        filename = ('./loss_results/' + 'loss2.png')
        plt2.savefig(filename)
        gc.collect()
        call(['mkdir ./delay_results'], shell=True)
        plt1.figure()
        plt2.figure()
        for algorithm in AlgorithmList:
            LossRateCPU = {}
            LossRateELAPSED = {}
            CPU_Times_sd = []
            Elapsed_Times_sd = []
            sde_time_cpu = {}
            elapsed_time_cpu = {}
            self.output('DELAY VARIATION', algorithm)
            print('\n')
            for nDelayValue in nDelayList:
                (cpuTime, elapsedTime) = (0, 0)
                for nrepeat in range(nrun):
                    monitor = self.new(Monitor, num=1)
                    acceptors = self.new(algorithm.Acceptor, num=nacceptors)
                    proposers = self.new(algorithm.Proposer, (acceptors, monitor, ntp, 0, nDelayValue, nwaitValue), num=nproposers)
                    learners = self.new(algorithm.Learner, num=nlearners)
                    self._setup(monitor, (learners, acceptors, proposers))
                    self._start(monitor)
                    for p in acceptors:
                        self._setup(p, (learners, monitor, nDelayValue))
                    for p in learners:
                        self._setup(p, (acceptors, monitor, ntl))
                    cpuStartTime = time.process_time()
                    elapsedStartTime = time.time()
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1141', block=False)
                    l = None

                    def UniversalOpExpr_1142():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1156.match_iter(self._Node_ReceivedEvent_1, _BoundPattern1162_=l)):
                                return False
                        return True
                    _st_label_1141 = 0
                    while (_st_label_1141 == 0):
                        _st_label_1141 += 1
                        if UniversalOpExpr_1142():
                            _st_label_1141 += 1
                        else:
                            super()._label('_st_label_1141', block=True)
                            _st_label_1141 -= 1
                    else:
                        if (_st_label_1141 != 2):
                            continue
                    if (_st_label_1141 != 2):
                        break
                    self.send(('done',), to=(acceptors | proposers))
                    cpuEndTime = time.process_time()
                    elapsedEndTime = time.time()
                    CPU_Times_sd.append(cpuTime)
                    Elapsed_Times_sd.append(elapsedTime)
                    cpuTime += (cpuEndTime - cpuStartTime)
                    elapsedTime += (elapsedEndTime - elapsedStartTime)
                    self.send(('done',), to=monitor)
                    gc.collect()
                cpuTime = float((cpuTime / nrun))
                elapsedTime = float((elapsedTime / nrun))
                LossRateCPU[round(nDelayValue, 2)] = round(cpuTime, 5)
                LossRateELAPSED[round(nDelayValue, 2)] = round(elapsedTime, 5)
                sde_time_cpu[round(nDelayValue, 2)] = round(stdev(CPU_Times_sd, xbar=0), 5)
                elapsed_time_cpu[round(nDelayValue, 2)] = round(stdev(Elapsed_Times_sd, xbar=0), 5)
            print('DELAY VARIATION v/s MEAN CPU TIME', LossRateCPU)
            print('DELAY VARIATION v/s MEAN ELAPSED TIME', LossRateELAPSED)
            print('STANDARD DEVIATION OF CPU TIME', sde_time_cpu)
            print('STANDARD DEVIATION OF ELAPSED TIME', elapsed_time_cpu)
            print('\n')
            lists = sorted(LossRateCPU.items())
            (x, y) = zip(*lists)
            plt1.plot(x, y, label='MessageDelayAvgCPUTime')
            lists2 = sorted(LossRateELAPSED.items())
            (x, y) = zip(*lists2)
            plt2.plot(x, y, label='MessageDelayAvgELAPSEDTime')
        plt1.legend(['BasicPaxosCPUTime', 'BasicPaxosELAPSEDTime', 'PremeptionCPUTime', 'PreemptionELAPSEDTime'], loc='upper left', prop={'size': 5})
        filename = ('./delay_results/' + 'delay1.png')
        plt1.savefig(filename)
        plt2.legend(['BasicPaxosCPUTime', 'BasicPaxosELAPSEDTime', 'PremeptionCPUTime', 'PreemptionELAPSEDTime'], loc='upper left', prop={'size': 5})
        filename = ('./delay_results/' + 'delay2.png')
        plt2.savefig(filename)
        gc.collect()
        call(['mkdir ./waittime_results'], shell=True)
        plt1.figure()
        plt2.figure()
        for algorithm in AlgorithmList:
            LossRateCPU = {}
            LossRateELAPSED = {}
            CPU_Times_sd = []
            Elapsed_Times_sd = []
            sde_time_cpu = {}
            elapsed_time_cpu = {}
            self.output('WAITIME VARIATION', algorithm)
            print('\n')
            for nwaitValue in nwaitList:
                (cpuTime, elapsedTime) = (0, 0)
                for nrepeat in range(nrun):
                    monitor = self.new(Monitor, num=1)
                    acceptors = self.new(algorithm.Acceptor, num=nacceptors)
                    proposers = self.new(algorithm.Proposer, (acceptors, monitor, ntp, (nlossrate / 5), 0, nwaitValue), num=nproposers)
                    learners = self.new(algorithm.Learner, num=nlearners)
                    self._setup(monitor, (learners, acceptors, proposers))
                    self._start(monitor)
                    for p in acceptors:
                        self._setup(p, (learners, monitor, nDelayValue))
                    for p in learners:
                        self._setup(p, (acceptors, monitor, ntl))
                    cpuStartTime = time.process_time()
                    elapsedStartTime = time.time()
                    self._start(((acceptors | proposers) | learners))
                    super()._label('_st_label_1536', block=False)
                    l = None

                    def UniversalOpExpr_1537():
                        nonlocal l
                        for l in learners:
                            if (not PatternExpr_1551.match_iter(self._Node_ReceivedEvent_2, _BoundPattern1557_=l)):
                                return False
                        return True
                    _st_label_1536 = 0
                    while (_st_label_1536 == 0):
                        _st_label_1536 += 1
                        if UniversalOpExpr_1537():
                            _st_label_1536 += 1
                        else:
                            super()._label('_st_label_1536', block=True)
                            _st_label_1536 -= 1
                    else:
                        if (_st_label_1536 != 2):
                            continue
                    if (_st_label_1536 != 2):
                        break
                    self.send(('done',), to=(acceptors | proposers))
                    cpuEndTime = time.process_time()
                    elapsedEndTime = time.time()
                    cpuTime += (cpuEndTime - cpuStartTime)
                    elapsedTime += (elapsedEndTime - elapsedStartTime)
                    CPU_Times_sd.append(cpuTime)
                    Elapsed_Times_sd.append(elapsedTime)
                    self.send(('done',), to=monitor)
                    gc.collect()
                cpuTime = float((cpuTime / nrun))
                elapsedTime = float((elapsedTime / nrun))
                LossRateCPU[round(nwaitValue, 2)] = round(cpuTime, 5)
                LossRateELAPSED[round(nwaitValue, 2)] = round(elapsedTime, 5)
                sde_time_cpu[round(nwaitValue, 2)] = round(stdev(CPU_Times_sd, xbar=0), 5)
                elapsed_time_cpu[round(nwaitValue, 2)] = round(stdev(Elapsed_Times_sd, xbar=0), 5)
            print('WAITTIME VARIATION v/s MEAN CPU TIME', LossRateCPU)
            print('WAITTIME VARIATION v/s ELAPSED CPU TIME', LossRateELAPSED)
            print('STANDARD DEVIATION OF CPU TIME', sde_time_cpu)
            print('STANDARD DEVIATION OF ELAPSED TIME', elapsed_time_cpu)
            print('\n')
            lists = sorted(LossRateCPU.items())
            (x, y) = zip(*lists)
            plt1.plot(x, y, label='MessageDelayAvgCPUTime')
            lists2 = sorted(LossRateELAPSED.items())
            (x, y) = zip(*lists2)
            plt2.plot(x, y, label='MessageDelayAvgELAPSEDTime')
        plt1.legend(['BasicPaxosCPUTime', 'BasicPaxosELAPSEDTime', 'PremeptionCPUTime', 'PreemptionELAPSEDTime'], loc='upper left', prop={'size': 5})
        filename = ('./waittime_results/' + 'Waittime1.png')
        plt1.savefig(filename)
        plt2.legend(['BasicPaxosCPUTime', 'BasicPaxosELAPSEDTime', 'PremeptionCPUTime', 'PreemptionELAPSEDTime'], loc='upper left', prop={'size': 5})
        filename = ('./waittime_results/' + 'Waittime2.png')
        plt2.savefig(filename)
